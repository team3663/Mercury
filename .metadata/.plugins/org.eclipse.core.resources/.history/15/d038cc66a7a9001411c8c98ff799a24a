package org.usfirst.frc.team3663.robot.subsystems;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Timer;

import org.usfirst.frc.team3663.robot.Robot;
import org.usfirst.frc.team3663.robot.commands.C_ArcadeDrive;

/**
 *
 */
public class DriveTrainSS extends Subsystem {
    
	CANTalon driveTalonL1, driveTalonL2, driveTalonR1, driveTalonR2;
	RobotDrive driveTrain;
	Encoder leftEncoder, rightEncoder;

	final int buffer = 10;
	final double lowSpeed = -0.3;
	final double topSpeed = 0.3;
	public boolean encoderDriveEnabled = true;
	int changeInTicksL, changeInTicksR,
	lastTicksL, lastTicksR, startTicksL, startTicksR, totalTickChangeL,
	totalTickChangeR;
	double timeDiff;
	
	//ramping---------------------------
	int desiredTicks = 0;
	double currSpeed;
	double tickSpeed;
	double lastTick, currTick;
	double lastTime, currTime;
	//----------------------------------
	int ticksRequiredToStop;
	double speed;///////////////////////////////////////
	double speedL, speedR;
	boolean beginning;
	int ticksPerRevL = 780;
	int ticksPerRevR = 780;//233;
	int currTicksL, currTicksR, ticks, ticksL, ticksR;
	double distBetweenCenterAndWheelInches = 10.0;
	double tickPerInch360 = 360/23.561944905;
	//turn variables---
	int ticksOutside, ticksInside;
	double speedVar;
	double rateAtFullPower;//ticks per second
	double magConvert;
	//-----------------

	public DriveTrainSS()
	{
		driveTalonL1 = new CANTalon(10);
		driveTalonL2 = new CANTalon(12);
		driveTalonR1 = new CANTalon(11);
		driveTalonR2 = new CANTalon(13);
		driveTrain = new RobotDrive(driveTalonL1, driveTalonL2, driveTalonR1, driveTalonR2);
		
		leftEncoder = new Encoder(6,7);
		rightEncoder = new Encoder(8,9);
	}
	
    public void initDefaultCommand() {
        // Set the default command for a subsystem here.
        setDefaultCommand(new C_ArcadeDrive());
    }
    
    public void arcadeDrive(Joystick joystick)
    {
    	driveTrain.arcadeDrive(joystick);
    	SmartDashboard.putNumber("leftEncoder: ", leftEncoder.get());
    	SmartDashboard.putNumber("rightEncoder: ", rightEncoder.get());
    }
    
    public boolean encoderDrive(int ticksDL, int ticksDR, boolean stopAtEnd)
    {
    	boolean encoderDriveFinished = false;
    	currTicksL = Robot.chassis.getLeftEncoderTicks();
    	currTicksR = Robot.chassis.getRightEncoderTicks();
		///left
    	if (currTicksL < ticksDL+buffer)
    	{
    		speedL+=0.0125;
    	}
    	else if (currTicksL > ticksDL-buffer)
    	{
    		speedL-=0.0125;
    	}
		if (speedL > topSpeed)
		{
			speedL = topSpeed;
		}
		else if (speedL < lowSpeed)
		{
			speedL = lowSpeed;
		}
		////right
		if (currTicksR < ticksDR+buffer)
    	{
    		speedR+=0.0125;
    	}
    	else if (currTicksR > ticksDR-buffer)
    	{
    		speedR-=0.0125;
    	}
		if (speedR > topSpeed)
		{
			speedR = topSpeed;
		}
		else if (speedR < lowSpeed)
		{
			speedR = lowSpeed;
		}
    	SmartDashboard.putNumber("leftEncoder: ", Robot.chassis.getLeftEncoderTicks());
    	SmartDashboard.putNumber("rightEncoder: ", Robot.chassis.getRightEncoderTicks());
    	totalTickChangeL = currTicksL - startTicksL;
    	totalTickChangeR = currTicksR - startTicksR;
    	if (ticksDL-currTicks <= 10 && stopAtEnd)
    	{
    		speedL = 0;
    		encoderDriveFinished = true;
    	}
		driveTalonL1.set(-speedR);
    	driveTalonL2.set(-speedR);
    	driveTalonR1.set(speedR);
    	driveTalonR2.set(speedR);
    	SmartDashboard.putNumber("desiredTicks", ticksDL);
    	SmartDashboard.putNumber("speed ", speedL);
    	
    	return encoderDriveFinished;
    }
    
    public boolean encoderDriveF(int inches)
    {
    	speed = 0;
    	beginning = true;
    	currTicksL = leftEncoder.get();
    	currTicksR = rightEncoder.get();
    	//conversion algorithm to ticks
    	ticksL = (int)(inches*tickPerInch360*780/360);
    	ticksR = (int)(inches*tickPerInch360*780/360);
    	while (leftEncoder.get() > (currTicksL - ticksL) || rightEncoder.get() < (currTicksR + ticksR))//see if && or ||
    	{
    		if (beginning)
    		{
    			while (speed < topSpeed && (currTicksL - leftEncoder.get()) < (ticksL)/2)//trying to make sure does not over accelerate if distance too short to fully accelerate
    			{
    	    		driveTalonL1.set(-speed);
    	        	driveTalonL2.set(-speed);
    	        	driveTalonR1.set(speed);
    	        	driveTalonR2.set(speed);
    	        	speed+=0.025;
    	        	beginning = false;
    			}
    		}
    		driveTalonL1.set(-speed);
        	driveTalonL2.set(-speed);
        	driveTalonR1.set(speed);
        	driveTalonR2.set(speed);
        	//distance calculation----
        	ticksRequiredToStop = (int)(speed*360/0.098);
        	//------------------------
 /*       	if ((currTicksL - leftEncoder.get()) > ticksL - ticksRequiredToStop)
        	{
        		speed-=(0.025);
        	}
    		//driveTrain.arcadeDrive(0.2,0);
        	SmartDashboard.putNumber("leftEncoder: ", leftEncoder.get());
        	SmartDashboard.putNumber("rightEncoder: ", rightEncoder.get());        */
        	if (currTicksL - leftEncoder.get() > ticksL/2)
        	{
        		speed = 0.2;
        	}
    	}
		driveTalonL1.set(0.0);
    	driveTalonL2.set(0.0);
    	driveTalonR1.set(0.0);
    	driveTalonR2.set(0.0);
    	
    	return true;
    }
    
    public boolean encoderDriveB(double inches)
    {

    	currTicksL = leftEncoder.get();
    	currTicksR = rightEncoder.get();
    	//conversion algorithm to ticks
    	ticksL = (int)(inches*tickPerInch360*780/360);
    	ticksR = (int)(inches*tickPerInch360*780/360);
    	while (leftEncoder.get() < (currTicksL + ticksL) || rightEncoder.get() > (currTicksR - ticksR))//see if && or ||
    	{
    		driveTalonL1.set(0.2);
        	driveTalonL2.set(0.2);
        	driveTalonR1.set(-0.2);
        	driveTalonR2.set(-0.2);
    		//driveTrain.arcadeDrive(-0.2, 0);
        	SmartDashboard.putNumber("leftEncoder: ", leftEncoder.get());
        	SmartDashboard.putNumber("rightEncoder: ", rightEncoder.get());
    	}
		driveTalonL1.set(0.0);
    	driveTalonL2.set(0.0);
    	driveTalonR1.set(0.0);
    	driveTalonR2.set(0.0);
    	
    	return true;
    }
    
    public boolean encoderTurn(boolean turningL, int radius, double degreeArc)
    {
    	speedVar = -0.5;
    	
    	currTicksL = leftEncoder.get();
    	currTicksR = rightEncoder.get();
    	
    	//algorithms
    	ticksOutside = (int)(tickPerInch360*(((radius + distBetweenCenterAndWheelInches)*2*3.141592654)*(degreeArc/360.0)));
    	ticksInside = (int)(tickPerInch360*(((radius - distBetweenCenterAndWheelInches)*2*3.141592654)*(degreeArc/360.0)));
    	if (turningL) rateAtFullPower = 360/0.156;//0.2: /0.801;//1.0: /0.098;
    	else rateAtFullPower = 360/0.156;//0.2: /2.292;//1.0: /0.362;
    	magConvert = rateAtFullPower;
    	speedVar = speedVar + ((ticksInside*rateAtFullPower/ticksOutside)/magConvert);//speedVar + ticksInside/ticksOutside
    	//end of algorithms
    	
    	SmartDashboard.putNumber("ticksInside", ticksInside);
		SmartDashboard.putNumber("ticksOutside", ticksOutside);
		
    	if (turningL)
    	{
    		ticksOutside = (ticksOutside*780)/360;
    		ticksInside = ticksInside*780/360;
    		
    		while (rightEncoder.get() < (currTicksR + ticksOutside))
    		{
	    		driveTalonL1.set(-(speedVar));
	        	driveTalonL2.set(-(speedVar));
	        	driveTalonR1.set(0.5);
	        	driveTalonR2.set(0.5);
	        	SmartDashboard.putNumber("leftEncoder: ", leftEncoder.get());
	        	SmartDashboard.putNumber("rightEncoder: ", rightEncoder.get());
    		}
    	}
    	else
    	{
    		ticksOutside = ticksOutside*780/360;
    		ticksInside = ticksInside*780/360;
    		while (leftEncoder.get() > currTicksL - ticksOutside)
    		{
	    		driveTalonL1.set(-(0.5));
	        	driveTalonL2.set(-(0.5));
	        	driveTalonR1.set(speedVar);
	        	driveTalonR2.set(speedVar);
	        	SmartDashboard.putNumber("leftEncoder: ", leftEncoder.get());
	        	SmartDashboard.putNumber("rightEncoder: ", rightEncoder.get());
    		}
    	}
    	SmartDashboard.putNumber("leftEncoderMoved", leftEncoder.get() - currTicksL);
    	SmartDashboard.putNumber("rightEncoderMoved", rightEncoder.get() - currTicksR);
    	SmartDashboard.putNumber("ticksOutside: ", ticksOutside);
    	
    	return true;
    }
    
    public void setSpeed(double Speed)
    {
    	speed = Speed;
    }
    
    public void setSpeedVar(double Speed)
    {
    	speedVar = Speed;
    }
    
    public void resetEncoders()
    {
    	leftEncoder.reset();
    	rightEncoder.reset();
    }
    
    public int getLeftEncoderTicks()
    {
    	return leftEncoder.get();
    }

    public int getRightEncoderTicks()
    {
    	return rightEncoder.get();
    }
    
    public void enableEncoderDrive()
    {
    	encoderDriveEnabled = true;
    }
    
    public void disableEncoderDrive()
    {
    	encoderDriveEnabled = false;
    }
}

